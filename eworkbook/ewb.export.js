/*!
 * Generates experiments out of meeting content in
 * IDBS E-WorkBook 10.1 using the REST API
 * Marvin Live example plugin example
 * @license MIT
 */

"use strict";


//"https://idbs-app.bpo.cxn:8443";
var server = process.env["EWORKBOOK_SERVER"];

//disable certificate checking for unsigned https
process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

// entity ID of /Root/TestGroup/New Synthesis
var projectId = process.env["PROJECT_ID"];


var credentials = {
	username: process.env["EWORKBOOK_USERNAME"],
	password: process.env["EWORKBOOK_PASSWORD"]
};


var Q = require("q");
var _ = require("lodash");
var request = require("request").defaults({
	jar: true,
	json: true,
	method: "POST",
	auth: credentials
});


var services = {
	addEntity: "/ewb/services/1.0/entities/%s/children",
	addEntityCache: "/ewb/services/1.0/cache/entities/%s/children",
	commit: "/ewb/services/1.0/cache/entities/%s/commit",
	lock: "/ewb/services/1.0/locks/entities/%s/lock",
	display: "/EWorkbookWebApp/#entity/displayEntity?entityId=%s&r=y&v=y"
};


//perform an HTTP request and return a promise
function req(opts) {
	console.log("%s %s", !opts.method ? "POST" : opts.method, opts.url);
	var dfd = Q.defer();
	request(opts, function(err, res, body) {
		if (err || !res || (res.statusCode !== 200 && res.statusCode !== 204)) {
			console.log(res && res.statusCode, opts.method, opts.url);
			dfd.reject(err);
		}
		dfd.resolve(body);
	});

	return dfd.promise;
}


function getEntityLink(entityId, service) {
	return server + services[service].replace("%s", entityId);
}


//lock and unlock an entity
function lock(entityId) {
	return req({
		method: "PUT",
		url: getEntityLink(entityId, "lock")
	});
}

function releaseLock(entityId) {
	return req({
		method: "DELETE",
		url: getEntityLink(entityId, "lock")
	});
}


//commit changes made through the cache
function commit(entityId) {
	return req({
		url: getEntityLink(entityId, "commit"),
		json: {
			"entityId" : entityId,
			"entityVersionType" : "DRAFT",
			"author" : {
				"reason" : "Initial state generated by Marvin Live"
			}
		}
	}).catch(function(err) {
		console.log("Couldn't lock the entity", entityId, err);
		return err;
	});
}


//create a new entity under a given a parent
function createEntity(parentId, data) {
	var entityDefinition = {
		entityType: data.type,
		entityName: data.name,
		attributes: {
			attribute: _.map(data.attributes, function(value, key) {
				if (value === null) {
					return {
						name: key,
						values: {}
					};
				}
				return {
					name: key,
					values: {
						value: [value]
					}
				};
			})
		}
	};

	if (data.data) {
		entityDefinition.data = {
			data: {
				dataText: data.data.text
			},
			dataInfo: {
				mimeType: data.data.mimeType,
				dataType: data.data.dataType,
				fileType: data.data.fileType
			}
		};
	}


	return req({
		url: getEntityLink(parentId, data.service),
		json: entityDefinition
	}).then(function(id) {

		return id;

	}).catch(function(err) {

		console.log("Couldn't create entity", data.type, err);
		return err;

	});
}


//process a snapshot and save all its data
function storeExperimentAndData(roomName, snapshot, projectId) {

	var experimentId;

	return createEntity(projectId, {
		service: "addEntity",
		type: "EXPERIMENT",
		name: roomName + " #" + (snapshot.snapshotId + 1),
		attributes: {
			title: roomName + " #" + (snapshot.snapshotId + 1),
			statusName: "Started"
		}
	}).then(function(newEntityId) {

		experimentId = newEntityId;
		return lock(experimentId);

	}).then(function() {

		//store chemistry content
		return createEntity(experimentId, {
			service: "addEntityCache",
			type: "DOCUMENT",
			name: "Chemistry",
			attributes: {
				itemType: "Chemistry",
				publishingState: "Unpublished"
			},
			data: {
				text: JSON.stringify({
					structure: snapshot.structure
				}),
				mimeType: "application/x-idbs-chemistry",
				fileType: ".mrv",
				dataType: "IDBS_CHEMISTRY"
			}
		});

	}).then(function() {

		//store key attributes
		var commentString = _.map(snapshot.comments, function(comment) {
			return comment.author + ": " + comment.message;
		}).join("<br>");

		return createEntity(experimentId, {
			service: "addEntityCache",
			type: "TEXT_DOCUMENT",
			name: "Key information",
			attributes: {
				itemType: "Key information",
				publishingState: "Unpublished"
			},
			data: {
				text: "Task: " + snapshot.task + "<br><br>" +
					"Author: " + snapshot.author + "<br><br>" +
					"Comments:<br>" + commentString,
				mimeType: "text/html",
				fileType: ".html",
				dataType: "HTML_TEXT"
			}
		});

	}).then(function() {

		//store data
		if (_.isEmpty(snapshot.data)) {
			return true;
		}

		var dataText = "";
		_.each(snapshot.data, function(values, type) {

			dataText += type + ":<br>";

			_.each(values, function(value, key) {
				dataText += key + ": " + value + "<br>";
			});

			dataText += "<br>";

		});

		return createEntity(experimentId, {
			service: "addEntityCache",
			type: "TEXT_DOCUMENT",
			name: "Predicted properties",
			attributes: {
				itemType: "Predicted properties",
				publishingState: "Unpublished"
			},
			data: {
				text: dataText,
				mimeType: "text/html",
				fileType: ".html",
				dataType: "HTML_TEXT"
			}
		});

	}).then(function() {

		return commit(experimentId);

	}).then(function() {

		return releaseLock(experimentId);

	}).then(function() {

		return experimentId;

	});
}


function generate(meetingData) {

	//select the snapshots from the meeting's structure list
	var filter = {
		snapshot: true
	};
	// jshint validthis: true
	if (this.selectedOnly) {
		filter.selected = true;
	}
	var roomName = this.roomName;

	var promises = _.chain(meetingData.structures).filter(filter).map(function(snapshot) {
		return storeExperimentAndData(roomName, snapshot, projectId);
	}).value();

	return Q.all(promises).then(function(results) {

		var links = _.map(results, function(experimentId) {
			return "* " + getEntityLink(experimentId, "display");
		}).join("\n\n");

		return "Created " + results.length + " experiments and saved as draft:\n" + links;

	}).catch(function(err) {

		console.log("Couldn't generate a report", err ? err.stack : arguments);
		return "An error occured during export. Please contact your administrator!";

	});

}


module.exports = {
	name: "ewb",
	label: "E-Workbook",
	domains: ["*"],
	generate: generate,
	returnType: "message",
	sortOrder: 80,
	type: "chemistry"
};